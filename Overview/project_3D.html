<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <title>
   MyMiniSlot - 3D Project Visualization
  </title>
  <style>
   body {
            margin: 0;
            overflow: hidden;
            font-family: 'Montserrat', sans-serif;
            background-color: #050608;
            color: #e0e0e0;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

#infoPanel {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(30, 37, 47, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 15px;
            width: 300px;
            max-height: 90vh;
            overflow-y: auto;
            z-index: 100;
            color: #e0e0e0;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            transition: transform 0.3s ease-out;
            transform: translateX(-110%); 
        }

#infoPanel.visible {
            transform: translateX(0);
        }

#infoPanel h2 {
            font-family: 'Orbitron', sans-serif;
            color: #fff;
            margin-top: 0;
            font-size: 1.2em;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding-bottom: 5px;
            margin-bottom: 10px;
        }

#infoPanel p, #infoPanel li {
            font-size: 0.9em;
            line-height: 1.6;
            margin-bottom: 8px;
        }

#infoPanel strong {
            color: #87CEEB; 
        }

#infoPanel ul {
            padding-left: 20px;
            margin-bottom:10px;
        }

#infoPanel a {
            color: #FFD700; 
            text-decoration: none;
        }

#infoPanel a:hover {
            text-decoration: underline;
        }

#closeInfoPanel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            color: #fff;
            font-size: 1.5em;
            cursor: pointer;
        }

#loadingScreen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: #050608;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }

#loadingScreen p {
            font-size: 1.2em;
            margin-bottom: 20px;
        }

#progressBarContainer {
            width: 300px;
            height: 20px;
            background-color: rgba(255,255,255,0.1);
            border-radius: 10px;
            overflow: hidden;
        }

#progressBar {
            width: 0%;
            height: 100%;
            background-color: #87CEEB;
            transition: width 0.2s ease;
        }

#tooltip {
            position: absolute;
            background-color: rgba(0,0,0,0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.8em;
            pointer-events: none; 
            display: none; 
            z-index: 101;
        }
  </style>
 </head>
 <body>
  <div id="infoPanel">
   <button id="closeInfoPanel">
    &times;
   </button>
   <div id="infoContent">
   </div>
  </div>
  <div id="tooltip">
  </div>
  <div id="loadingScreen">
   <p>
    Loading Project Visualization...
   </p>
   <div id="progressBarContainer">
    <div id="progressBar">
    </div>
   </div>
  </div>
  <script type="importmap">
   {
       "imports": {
           "three": "https:
           "three/addons/": "https:
       }
   }
  </script>
  <script type="module">
   import * as THREE from 'three';
   import {
       OrbitControls
   } from 'three/addons/controls/OrbitControls.js';
   import {
       CSS2DRenderer,
       CSS2DObject
   } from 'three/addons/renderers/CSS2DRenderer.js';
   import {
       UnrealBloomPass
   } from 'three/addons/postprocessing/UnrealBloomPass.js';
   import {
       EffectComposer
   } from 'three/addons/postprocessing/EffectComposer.js';
   import {
       RenderPass
   } from 'three/addons/postprocessing/RenderPass.js';
   const projectData = {
       name: "MyMiniSlot Project",
       files: [{
           name: "index.html",
           path: "index.html",
           type: "html",
           title: "Casino Prostotiq Home",
           loc: 220,
           linkedCss: ["all.css", "styles/2ndpage.css", "styles/footer.css"],
           linkedJs: ["js/2ndpage.js", "js/header.js"],
           sections: ["home", "craftsmanship", "experience", "pre-order"],
           imagesUsed: ["image/backgroundMainPage.jpg", "image/homePageImage_4.png", "image/machine.png.png", "image/ExperienceImage.webp", "image/pragmatic.png", "image/hacksaw.png", "image/unde.png", "image/helio.png", "image/lightingBox.webp", "image/amusnet.png", "image/igt.png", "image/playtech.png", "image/netent.png", "image/evolution.png", "image/nolimit.png", "image/everyMatrix.png", "image/Home__7_-removebg-preview.png", "image/360_icon.png", "image/footer-credits-removebg-preview.png", "image/Home (15).png", "image/Home (16).png", "image/Home (17).png", "image/Home (18).png"],
           description: "Main landing page showcasing the MyMiniSlot product with multiple sections and interactive elements."
       }, {
           name: "privacy-policy.html",
           path: "privacy-policy.html",
           type: "html",
           title: "Privacy Policy",
           loc: 80,
           linkedCss: ["all.css", "styles/2ndpage.css", "styles/privacy-policy.css"],
           linkedJs: [],
           imagesUsed: ["image/chip.png"],
           description: "Page detailing the privacy policy, structured with text columns and a sidebar image."
       }, {
           name: "about-us.html",
           path: "about-us.html",
           type: "html",
           title: "About Us - MyMiniSlot",
           loc: 130,
           linkedCss: ["all.css", "styles/footer.css"],
           linkedJs: ["js/header.js"],
           imagesUsed: ["image/ExperienceImage.webp"],
           description: "Provides information about the MyMiniSlot company/product, with text content and a device showcase image."
       }, {
           name: "cookie-policy.html",
           path: "cookie-policy.html",
           type: "html",
           title: "Cookie Policy - MyMiniSlot",
           loc: 90,
           linkedCss: ["all.css", "styles/cookie-policy.css"],
           linkedJs: ["js/header.js"],
           imagesUsed: ["image/coinsWithShadows.png"],
           description: "Explains the cookie usage policy, featuring a distinctive layout with a large coin image and split text columns."
       }, {
           name: "all.css",
           path: "all.css",
           type: "css",
           loc: 430,
           imports: ["image/backgroundMainPage.jpg"],
           description: "Global stylesheet for consistent look and feel, navigation, hero section, and base page layouts."
       }, {
           name: "footer.css",
           path: "styles/footer.css",
           type: "css",
           loc: 100,
           imports: ["image/backgroundMainPage.jpg"],
           description: "Styles for the site footer, including links, social icons, and crypto logos."
       }, {
           name: "privacy-policy.css",
           path: "styles/privacy-policy.css",
           type: "css",
           loc: 200,
           description: "Specific styles for the Privacy Policy page, including layout of text columns and sidebar image."
       }, {
           name: "2ndpage.css",
           path: "styles/2ndpage.css",
           type: "css",
           loc: 230,
           imports: ["../image/backgroundMainPage.jpg"],
           description: "Styles for the 'craftsmanship' section (feature labels, connecting lines) on the main page."
       }, {
           name: "cookie-policy.css",
           path: "styles/cookie-policy.css",
           type: "css",
           loc: 250,
           description: "Styling for the Cookie Policy page, managing the layout with the large coin image and text columns."
       }, {
           name: "header.js",
           path: "js/header.js",
           type: "js",
           loc: 160,
           description: "Handles header navigation, active section highlighting based on scroll, smooth scrolling, mobile menu toggle, and dynamic indicator positioning. Manages navigation for main page sections: home, craftsmanship, experience, pre-order.",
           interactsWithDOM: ["#main-header", "#main-nav", ".nav-link", "#indicator", "#mobile-menu-toggle", ".logo-text", "section[id]", ".hero-section[id]"]
       }, {
           name: "2ndpage.js",
           path: "js/2ndpage.js",
           type: "js",
           loc: 120,
           description: "Manages interactive feature labels with hover effects and clickable dropdowns on the craftsmanship section. Animates connecting lines on scroll visibility. Dynamically creates styles for dropdowns and line animations.",
           interactsWithDOM: [".feature-label", ".feature-dropdown", ".connecting-line line", ".connecting-line circle", "#craftsmanship"]
       }, {
           name: "package.json",
           path: "package.json",
           type: "json",
           loc: 10,
           content: {
               name: "casino_prostotiq",
               version: "1.0.0",
               main: "index.js",
               scripts: {
                   dev: "vite"
               },
               dependencies: {
                   vite: "^6.3.5"
               }
           },
           description: "Project metadata and dependencies, configured to use Vite for development."
       }, {
           name: "package-lock.json",
           path: "package-lock.json",
           type: "json",
           loc: 1000,
           description: "Records the exact versions of project dependencies, ensuring reproducible builds."
       }, {
           name: "backgroundMainPage.jpg",
           path: "image/backgroundMainPage.jpg",
           type: "image",
           description: "Main background image used across the site."
       }, {
           name: "chip.png",
           path: "image/chip.png",
           type: "image",
           description: "Decorative chip image used on the privacy policy page."
       }, {
           name: "coinsWithShadows.png",
           path: "image/coinsWithShadows.png",
           type: "image",
           description: "Image of coins, used on the cookie policy page."
       }, {
           name: "ExperienceImage.webp",
           path: "image/ExperienceImage.webp",
           type: "image",
           description: "Image showcasing the device, used in 'experience' and 'about-us' sections."
       }, {
           name: "homePageImage_4.png",
           path: "image/homePageImage_4.png",
           type: "image",
           description: "Primary product image for the hero section on the homepage."
       }, {
           name: "machine.png.png",
           path: "image/machine.png.png",
           type: "image",
           description: "Product image used in the 'craftsmanship' section for feature callouts."
       }, {
           name: "Home__7_-removebg-preview.png",
           path: "image/Home__7_-removebg-preview.png",
           type: "image",
           description: "Product image for the 'pre-order' section."
       }, ],
       imageAssets: [
           "image/360_icon.png", "image/EveryMatrix_logo.png", "image/Evolution_logo.png",
           "image/Hacksaw_logo.png", "image/Helio_logo.png", "image/IGT_logo.png", "image/NetEnt_logo.png",
           "image/Nolimit_City_logo.png", "image/Playtech_logo.png", "image/Pragmatic_Play_logo.png",
           "image/credits-crypto-logos.png", "image/dark_background_empty_room.jpg",
           "image/footer-credits-removebg-preview.png", "image/myminslot_logo_text.png",
           "image/Amusnet_logo.png"
       ]
   };
   let scene, camera, renderer, labelRenderer, controls, composer;
   let raycaster, mouse;
   const interactableObjects = [];
   let focusedObject = null;
   const initialCameraPosition = new THREE.Vector3(0, 5, 25);
   const infoPanel = document.getElementById('infoPanel');
   const infoContent = document.getElementById('infoContent');
   const closeInfoPanelButton = document.getElementById('closeInfoPanel');
   const tooltip = document.getElementById('tooltip');
   const loadingManager = new THREE.LoadingManager();
   const textureLoader = new THREE.TextureLoader(loadingManager);
   const progressBar = document.getElementById('progressBar');
   const loadingScreen = document.getElementById('loadingScreen');
   loadingManager.onProgress = function(url, itemsLoaded, itemsTotal) {
       progressBar.style.width = (itemsLoaded / itemsTotal * 100) + '%';
   };
   loadingManager.onLoad = function() {
       setTimeout(() => {
           loadingScreen.style.display = 'none';
           animate();
       }, 500);
   };
   const fileTypeColors = {
       html: 0x4A90E2,
       css: 0x50E3C2,
       js: 0xF8E71C,
       json: 0xE67E22,
       image: 0xBD10E0
   };

   function init() {
       scene = new THREE.Scene();
       scene.fog = new THREE.FogExp2(0x050608, 0.02);
       camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
       camera.position.copy(initialCameraPosition);
       renderer = new THREE.WebGLRenderer({
           antialias: true
       });
       renderer.setSize(window.innerWidth, window.innerHeight);
       renderer.setPixelRatio(window.devicePixelRatio);
       renderer.setClearColor(0x050608);
       document.body.appendChild(renderer.domElement);
       labelRenderer = new CSS2DRenderer();
       labelRenderer.setSize(window.innerWidth, window.innerHeight);
       labelRenderer.domElement.style.position = 'absolute';
       labelRenderer.domElement.style.top = '0px';
       labelRenderer.domElement.style.pointerEvents = 'none';
       document.body.appendChild(labelRenderer.domElement);
       controls = new OrbitControls(camera, renderer.domElement);
       controls.enableDamping = true;
       controls.dampingFactor = 0.05;
       controls.minDistance = 5;
       controls.maxDistance = 100;
       controls.target.set(0, 2, 0);
       const ambientLight = new THREE.AmbientLight(0x404040, 2);
       scene.add(ambientLight);
       const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
       directionalLight.position.set(5, 10, 7.5);
       scene.add(directionalLight);
       const renderScene = new RenderPass(scene, camera);
       const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.7, 0.5, 0.3);
       composer = new EffectComposer(renderer);
       composer.addPass(renderScene);
       composer.addPass(bloomPass);
       raycaster = new THREE.Raycaster();
       mouse = new THREE.Vector2();
       populateScene();
       createFileTypeChart();
       window.addEventListener('resize', onWindowResize);
       renderer.domElement.addEventListener('mousemove', onMouseMove);
       renderer.domElement.addEventListener('click', onClick);
       closeInfoPanelButton.addEventListener('click', () => {
           infoPanel.classList.remove('visible');
           if (focusedObject && focusedObject.material.emissive) {
               focusedObject.material.emissive.setHex(0x000000);
           }
           focusedObject = null;
           gsap.to(camera.position, {
               duration: 1,
               x: initialCameraPosition.x,
               y: initialCameraPosition.y,
               z: initialCameraPosition.z,
               onUpdate: () => controls.update()
           });
           gsap.to(controls.target, {
               duration: 1,
               x: 0,
               y: 2,
               z: 0,
               onUpdate: () => controls.update()
           });
       });
       if (typeof gsap === 'undefined') {
           console.warn("GSAP library not found. Animations might be less smooth.");
           window.gsap = {
               to: function(target, options) {
                   const duration = options.duration || 1;
                   const steps = duration * 60;
                   let currentStep = 0;
                   const startValues = {};
                   const endValues = {};
                   for (const key in options) {
                       if (target[key] !== undefined && typeof target[key] === 'number') {
                           startValues[key] = target[key];
                           endValues[key] = options[key];
                       }
                   }

                   function step() {
                       currentStep++;
                       const t = currentStep / steps;
                       for (const key in startValues) {
                           target[key] = startValues[key] + (endValues[key] - startValues[key]) * t;
                       }
                       if (options.onUpdate) options.onUpdate();
                       if (currentStep < steps) requestAnimationFrame(step);
                       else if (options.onComplete) options.onComplete();
                   }
                   requestAnimationFrame(step);
               }
           };
       }
   }

   function createNode(fileData, position, isCentral = false) {
       let geometry, material, node;
       const color = fileTypeColors[fileData.type] || 0xaaaaaa;
       if (fileData.type === 'html') {
           geometry = new THREE.SphereGeometry(isCentral ? 1 : 0.6, 32, 32);
       } else if (fileData.type === 'css') {
           geometry = new THREE.CylinderGeometry(0.3, 0.3, 0.8, 32);
       } else if (fileData.type === 'js') {
           geometry = new THREE.BoxGeometry(0.7, 0.7, 0.7);
       } else if (fileData.type === 'json') {
           geometry = new THREE.CapsuleGeometry(0.3, 0.4, 16, 32);
       } else if (fileData.type === 'image') {
           try {
               const texture = textureLoader.load(fileData.path);
               geometry = new THREE.PlaneGeometry(1, 1);
               material = new THREE.MeshStandardMaterial({
                   map: texture,
                   side: THREE.DoubleSide,
                   transparent: true
               });
           } catch (e) {
               geometry = new THREE.OctahedronGeometry(0.5);
           }
       } else {
           geometry = new THREE.TetrahedronGeometry(0.5);
       }
       if (!material) material = new THREE.MeshStandardMaterial({
           color: color,
           roughness: 0.5,
           metalness: 0.2,
           transparent: true,
           opacity: 0.85
       });
       node = new THREE.Mesh(geometry, material);
       node.position.copy(position);
       node.userData = fileData;
       scene.add(node);
       interactableObjects.push(node);
       const labelDiv = document.createElement('div');
       labelDiv.className = 'file-label';
       labelDiv.textContent = fileData.name;
       labelDiv.style.color = 'white';
       labelDiv.style.fontSize = '12px';
       labelDiv.style.backgroundColor = 'rgba(0,0,0,0.5)';
       labelDiv.style.padding = '2px 5px';
       labelDiv.style.borderRadius = '3px';
       const label = new CSS2DObject(labelDiv);
       label.position.set(0, (isCentral || fileData.type === 'html' ? 1.2 : 0.7), 0);
       node.add(label);
       node.scale.set(0.01, 0.01, 0.01);
       gsap.to(node.scale, {
           duration: 0.8,
           x: 1,
           y: 1,
           z: 1,
           ease: "elastic.out(1, 0.5)",
           delay: Math.random() * 1.5
       });
       return node;
   }

   function createConnection(startNode, endNode, color = 0x888888) {
       const points = [startNode.position, endNode.position];
       const geometry = new THREE.BufferGeometry().setFromPoints(points);
       const material = new THREE.LineBasicMaterial({
           color: color,
           transparent: true,
           opacity: 0.5
       });
       const line = new THREE.Line(geometry, material);
       scene.add(line);
       return line;
   }

   function populateScene() {
       const htmlFiles = projectData.files.filter(f => f.type === 'html');
       const otherFiles = projectData.files.filter(f => f.type !== 'html');
       const nodesMap = new Map();
       const projectRootNode = createNode({
           name: projectData.name,
           type: 'project'
       }, new THREE.Vector3(0, 8, 0), true);
       nodesMap.set(projectData.name, projectRootNode);
       htmlFiles.forEach((file, index) => {
           const angle = (index / htmlFiles.length) * Math.PI * 2;
           const radius = 6;
           const position = new THREE.Vector3(Math.cos(angle) * radius, 5, Math.sin(angle) * radius);
           const htmlNode = createNode(file, position);
           nodesMap.set(file.path, htmlNode);
           createConnection(projectRootNode, htmlNode, 0xaaaaaa);
           const relatedAssetTypes = ['css', 'js', 'image'];
           let assetIndex = 0;
           projectData.files.forEach(assetFile => {
               if ((file.linkedCss && file.linkedCss.includes(assetFile.name)) ||
                   (file.linkedJs && file.linkedJs.includes(assetFile.name)) ||
                   (file.imagesUsed && file.imagesUsed.includes(assetFile.path) && assetFile.type === 'image')) {
                   if (!nodesMap.has(assetFile.path)) {
                       const assetAngle = assetIndex * (Math.PI * 2 / 10);
                       const assetRadius = 2.5;
                       const assetPosition = new THREE.Vector3(
                           htmlNode.position.x + Math.cos(assetAngle) * assetRadius,
                           htmlNode.position.y + Math.sin(assetAngle) * (assetRadius * 0.5) - 1,
                           htmlNode.position.z + Math.sin(assetAngle) * assetRadius
                       );
                       const assetNode = createNode(assetFile, assetPosition);
                       nodesMap.set(assetFile.path, assetNode);
                       assetIndex++;
                   }
                   const assetNodeInstance = nodesMap.get(assetFile.path);
                   if (assetNodeInstance) {
                       createConnection(htmlNode, assetNodeInstance, fileTypeColors[assetFile.type] || 0x888888);
                   }
               }
           });
       });
       let globalAssetIndex = 0;
       otherFiles.forEach(file => {
           if (!nodesMap.has(file.path)) {
               const angle = (globalAssetIndex / (otherFiles.length - htmlFiles.length + 1)) * Math.PI * 2;
               const radius = 12;
               const position = new THREE.Vector3(Math.cos(angle) * radius, 1, Math.sin(angle) * radius);
               const node = createNode(file, position);
               nodesMap.set(file.path, node);
               if (file.type === 'json' && file.name === 'package.json') {
                   createConnection(projectRootNode, node, fileTypeColors.json);
               }
               globalAssetIndex++;
           }
       });
   }

   function createFileTypeChart() {
       const fileCounts = {};
       projectData.files.forEach(file => {
           fileCounts[file.type] = (fileCounts[file.type] || 0) + 1;
       });
       const chartGroup = new THREE.Group();
       chartGroup.position.set(-10, 1, -10);
       scene.add(chartGroup);
       let currentX = 0;
       const barWidth = 0.8;
       const barSpacing = 0.4;
       for (const type in fileCounts) {
           const count = fileCounts[type];
           const color = fileTypeColors[type] || 0xaaaaaa;
           const barHeight = count * 0.5;
           const barGeometry = new THREE.BoxGeometry(barWidth, barHeight, barWidth);
           const barMaterial = new THREE.MeshStandardMaterial({
               color: color,
               roughness: 0.7,
               metalness: 0.1
           });
           const bar = new THREE.Mesh(barGeometry, barMaterial);
           bar.position.set(currentX + barWidth / 2, barHeight / 2, 0);
           bar.userData = {
               type: 'chart-bar',
               fileType: type,
               count: count,
               name: `${type.toUpperCase()} Files (${count})`
           };
           chartGroup.add(bar);
           interactableObjects.push(bar);
           const labelDiv = document.createElement('div');
           labelDiv.textContent = type.toUpperCase();
           labelDiv.style.color = 'white';
           labelDiv.style.fontSize = '10px';
           labelDiv.style.textAlign = 'center';
           const label = new CSS2DObject(labelDiv);
           label.position.set(currentX + barWidth / 2, -0.3, 0);
           chartGroup.add(label);
           currentX += barWidth + barSpacing;
       }
       const titleDiv = document.createElement('div');
       titleDiv.textContent = 'File Type Distribution';
       titleDiv.style.color = '#FFF';
       titleDiv.style.fontSize = '16px';
       titleDiv.style.fontFamily = 'Orbitron, sans-serif';
       titleDiv.style.padding = '5px';
       titleDiv.style.backgroundColor = 'rgba(0,0,0,0.5)';
       const titleLabel = new CSS2DObject(titleDiv);
       titleLabel.position.set(currentX / 2 - barSpacing, Math.max(...Object.values(fileCounts)) * 0.5 + 1, 0);
       chartGroup.add(titleLabel);
   }

   function onWindowResize() {
       camera.aspect = window.innerWidth / window.innerHeight;
       camera.updateProjectionMatrix();
       renderer.setSize(window.innerWidth, window.innerHeight);
       labelRenderer.setSize(window.innerWidth, window.innerHeight);
       composer.setSize(window.innerWidth, window.innerHeight);
   }

   function onMouseMove(event) {
       mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
       mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
       raycaster.setFromCamera(mouse, camera);
       const intersects = raycaster.intersectObjects(interactableObjects);
       if (intersects.length > 0) {
           const intersectedObject = intersects[0].object;
           if (intersectedObject.userData && intersectedObject.userData.name) {
               tooltip.style.display = 'block';
               tooltip.style.left = (event.clientX + 10) + 'px';
               tooltip.style.top = (event.clientY - 20) + 'px';
               tooltip.textContent = intersectedObject.userData.name;
               document.body.style.cursor = 'pointer';
           }
       } else {
           tooltip.style.display = 'none';
           document.body.style.cursor = 'default';
       }
   }

   function onClick(event) {
       raycaster.setFromCamera(mouse, camera);
       const intersects = raycaster.intersectObjects(interactableObjects);
       if (intersects.length > 0) {
           const clickedObject = intersects[0].object;
           const data = clickedObject.userData;
           if (focusedObject && focusedObject.material.emissive) {
               focusedObject.material.emissive.setHex(0x000000);
           }
           focusedObject = clickedObject;
           if (focusedObject.material.emissive) {
               focusedObject.material.emissive.setHex(0x555555);
           }
           displayInfo(data);
           infoPanel.classList.add('visible');
           const targetPosition = new THREE.Vector3();
           clickedObject.getWorldPosition(targetPosition);
           const offset = camera.position.clone().sub(controls.target).normalize().multiplyScalar(5);
           gsap.to(camera.position, {
               duration: 1.2,
               x: targetPosition.x + offset.x,
               y: targetPosition.y + offset.y + 1,
               z: targetPosition.z + offset.z,
               ease: "power2.inOut",
               onUpdate: () => controls.update()
           });
           gsap.to(controls.target, {
               duration: 1.2,
               x: targetPosition.x,
               y: targetPosition.y,
               z: targetPosition.z,
               ease: "power2.inOut",
               onUpdate: () => controls.update()
           });
       } else {
           if (!infoPanel.contains(event.target) && event.target !== closeInfoPanelButton) {
               infoPanel.classList.remove('visible');
               if (focusedObject && focusedObject.material.emissive) {
                   focusedObject.material.emissive.setHex(0x000000);
               }
               focusedObject = null;
           }
       }
   }

   function displayInfo(data) {
       if (!data) {
           infoContent.innerHTML = "<p>No data available.</p>";
           return;
       }
       let html = `<h2>${data.name || 'Unnamed Node'}</h2>`;
       html += `<p><strong>Type:</strong> ${data.type || 'N/A'}</p>`;
       if (data.path) html += `<p><strong>Path:</strong> ${data.path}</p>`;
       if (data.loc) html += `<p><strong>Lines of Code (approx):</strong> ${data.loc}</p>`;
       if (data.title) html += `<p><strong>Title:</strong> ${data.title}</p>`;
       if (data.description) html += `<p><strong>Description:</strong> ${data.description}</p>`;
       if (data.type === 'html') {
           if (data.linkedCss && data.linkedCss.length > 0) {
               html += `<p><strong>Linked CSS:</strong><ul>${data.linkedCss.map(css => `<li>${css}</li>`).join('')}</ul></p>`;
           }
           if (data.linkedJs && data.linkedJs.length > 0) {
               html += `<p><strong>Linked JS:</strong><ul>${data.linkedJs.map(js => `<li>${js}</li>`).join('')}</ul></p>`;
           }
           if (data.sections && data.sections.length > 0) {
               html += `<p><strong>Nav Sections:</strong><ul>${data.sections.map(s => `<li>#${s}</li>`).join('')}</ul></p>`;
           }
           if (data.imagesUsed && data.imagesUsed.length > 0) {
               html += `<p><strong>Images Used (sample):</strong><ul>${data.imagesUsed.slice(0,3).map(img => `<li>${img}</li>`).join('')}${data.imagesUsed.length > 3 ? '<li>...and more</li>' : ''}</ul></p>`;
           }
       }
       if (data.type === 'css' && data.imports && data.imports.length > 0) {
           html += `<p><strong>Key Imports/URLs:</strong><ul>${data.imports.map(imp => `<li>${imp}</li>`).join('')}</ul></p>`;
       }
       if (data.type === 'js' && data.interactsWithDOM && data.interactsWithDOM.length > 0) {
           html += `<p><strong>Interacts with DOM (sample):</strong><ul>${data.interactsWithDOM.slice(0,3).map(dom => `<li>${dom}</li>`).join('')}${data.interactsWithDOM.length > 3 ? '<li>...and more</li>' : ''}</ul></p>`;
       }
       if (data.type === 'json' && data.content) {
           html += `<p><strong>Content (partial):</strong><pre style="font-size:0.8em; background:#111; padding:5px; border-radius:3px; max-height:100px; overflow:auto;">${JSON.stringify(data.content, null, 2).substring(0, 300)}...</pre></p>`;
       }
       if (data.type === 'image' && data.path) {
           html += `<p><img src="${data.path}" alt="${data.name}" style="max-width:100%; border-radius:4px; margin-top:10px;"></p>`;
       }
       if (data.type === 'chart-bar') {
           html = `<h2>Chart: ${data.fileType.toUpperCase()}</h2>`;
           html += `<p><strong>File Type:</strong> ${data.fileType}</p>`;
           html += `<p><strong>Count:</strong> ${data.count}</p>`;
       }
       infoContent.innerHTML = html;
   }

   function animate() {
       requestAnimationFrame(animate);
       controls.update();
       interactableObjects.forEach(obj => {
           if (obj.userData && obj.userData.type !== 'chart-bar' && obj !== focusedObject) {
               obj.rotation.y += 0.002 * (obj.userData.type === 'js' ? 1.5 : (obj.userData.type === 'css' ? -1 : 0.5));
           }
       });
       composer.render();
       labelRenderer.render(scene, camera);
   }
   const gsapScript = document.createElement('script');
   gsapScript.src = 'https:
   gsapScript.onload = () => {
       console.log("GSAP loaded.");
       init();
   };
   gsapScript.onerror = () => {
       console.warn("Failed to load GSAP. Animations might be less smooth.");
       init();
   };
   document.head.appendChild(gsapScript);
  </script>
 </body>
</html>
